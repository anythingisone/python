# 问题
    d_lis = [1,2,3,4,4,5,6]
    for i in d_lis:
        if i == 4:
        del d_lis[d_lis.index(i)]
    print(d_lis)
    输出结果：  
        [1,2,3,4,5,6]
# 原因
    遍历会自动按照位置索引遍历，当删除列表中某个元素时，后面的元素自动补齐，索引值减一，紧邻替补上来的元素占据了删除的元素位置，但遍历会按照当前位置遍历过而继续遍历，所以会导致删除元素时，遍历不完整。
# 解决方案
    采用递归:
        b = [1,2,3,4,4,4,4,5,4,4]
        def del_list(d_lis):
            for i in d_lis:
                if i == 4:
                    del d_lis[d_lis.index(i)]
                    del_list(d_lis)
                    break
        del_list(b)
        print(b)
    输出结果：
        [1,2,3,5]
    每当删除一个元素，递归刷新重新遍历
    递归弊端：
        会重复遍历已遍历过的值，增加CPU消耗
    优化：while循环控制索引位置
        i = 0
        d_lis = [1,2,3,4,4,5,6,4,4,4]
        while i < len(d_lis):
            if d_lis[i] == 4:
                del d_lis[i]
                i -= 1
            i += 1
        print(d_lis)
    输出结果：
        [1, 2, 3, 5, 6]
    每当删除一个元素，让i值减一，保持在当前位置
# 新问题
    递归时发现，把列表当参数传递给函数，在函数内部修改形参值，原来列表也被修改。python函数参数传递的方式是什么
# 原因
    python的函数参数传递不同于Java或C有两种方式：值传递和引用传递，python的参数传递实质上就是赋值的过程。形参 = 实参
    python的赋值特特点：
    （1）当赋值为数字或字符时，无论分开还是连续赋值，都指向同一内存地址：
        a = 1
        b = 1
        与
        a = b = 1
        效果一样
    赋值时会现在内存中寻找看1是否已经存在，若存在则让b也指向这块内存。这样做会节省内存空间。
    修改a或b的值不会对彼此产生影响。原因在于字符类型是不可修改的，若要改变a或b的值只能重新赋值，重新赋值就会开辟一块新的内存空间，存储新值，这样不会对未修改的变量值产生影响。
    （2）当赋值为列表时，分开赋值与同时赋值就会产生区别：
        a = [1]
        b = [1]
        这种方式a和b指向不同的内存空间，修改a列表的值不会对b产生影响
        a = b = [1]
        这种方式a和b指向同一内存，修改a的值，相应的b也会改变。这就是为什么修改形参的值为什么实参也会跟着改变的原因。